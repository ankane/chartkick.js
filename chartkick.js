// Generated by CoffeeScript 1.6.3
(function() {
  var Chartkick, chartError, createDataTable, defaultOptions, errorCatcher, extend, fetchDataSource, getJSON, hideLegend, isArray, isPlainObject, jsOptions, jsOptionsFunc, loaded, merge, negativeValues, parseISO8601, processColumnData, processLineData, processPieData, processSeries, renderColumnChart, renderLineChart, renderPieChart, setElement, setMax, setMin, setText, sortByTime, toArr, toDate, toFloat, toStr, waitForLoaded;

  isArray = function(variable) {
    return Object.prototype.toString.call(variable) === "[object Array]";
  };

  isPlainObject = function(variable) {
    return variable instanceof Object;
  };

  extend = function(target, source) {
    var key, _results;
    _results = [];
    for (key in source) {
      if (isPlainObject(source[key]) || isArray(source[key])) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
          target[key] = {};
        }
        if (isArray(source[key]) && !isArray(target[key])) {
          target[key] = [];
        }
        _results.push(extend(target[key], source[key]));
      } else if (source[key](inst(void 0))) {
        _results.push(target[key] = source[key]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  merge = function(obj1, obj2) {
    var target;
    target = {};
    extend(target, obj1);
    extend(target, obj2);
    return target;
  };

  this.ISO8601_PATTERN = /(\d\d\d\d)(\-)?(\d\d)(\-)?(\d\d)(T)?(\d\d)(:)?(\d\d)?(:)?(\d\d)?([\.,]\d+)?($|Z|([\+\-])(\d\d)(:)?(\d\d)?)/i;

  this.DECIMAL_SEPARATOR = String(1.5).charAt(1);

  parseISO8601 = function(input) {
    var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year;
    type = Object.prototype.toString.call(input);
    if (type === '[object Date]') {
      return input;
    }
    if (type !== '[object String]') {
      return;
    }
    if ((matches = input.match(this.ISO8601_PATTERN))) {
      year = parseInt(matches[1], 10);
      month = parseInt(matches[3], 10) - 1;
      day = parseInt(matches[5], 10);
      hour = parseInt(matches[7], 10);
      minutes = matches[9] ? parseInt(matches[9], 10) : 0;
      seconds = matches[11] ? parseInt(matches[11], 10) : 0;
      milliseconds = matches[12] ? parseFloat(this.DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;
      result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);
      if (matches[13] && matches[14]) {
        offset = matches[15] * 60;
        if (matches[17]) {
          offset += parseInt(matches[17], 10);
        }
        offset *= matches[14] === '-' ? -1 : 1;
        result -= offset * 60 * 1000;
      }
      return new Date(result);
    }
  };

  negativeValues = function(series) {
    var data, i, j, _i, _j, _len, _len1;
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      i = series[_i];
      data = series[i].data;
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        j = data[_j];
        if (data[j][1] < 0) {
          return true;
        }
      }
    }
    return false;
  };

  jsOptionsFunc = function(defaultOptions, hideLegend, setMin, setMax) {
    return function(series, opts) {
      var options;
      options = merge({}, defaultOptions);
      if (opts.hideLegend) {
        hideLegend(options);
      }
      if ("min" in opts) {
        setMin(options, opts.min);
      } else if (!negativeValues(series)) {
        setMin(options, 0);
      }
      if ("max" in opts) {
        setMax(options, opts.max);
      }
      options = merge(options, opts.library || {});
      return options;
    };
  };

  if ("Highcharts" in window) {
    defaultOptions = {
      xAxis: {
        labels: {
          style: {
            fontSize: "12px"
          }
        }
      },
      yAxis: {
        title: {
          text: null
        },
        labels: {
          style: {
            fontSize: "12px"
          }
        }
      },
      title: {
        text: null
      },
      credits: {
        enabled: false
      },
      legend: {
        borderWidth: 0
      },
      tooltip: {
        style: {
          fontSize: "12px"
        }
      }
    };
    hideLegend = function(options) {
      return options.legend.enabled = false;
    };
    setMin = function(options, min) {
      return options.yAxis.min = min;
    };
    setMax = function(options, max) {
      return options.yAxis.max = max;
    };
    jsOptions = HighChartLib.jsOptionsFunc(defaultOptions, hideLegend, setMin, setMax);
    renderLineChart = function(element, series, opts) {
      var data, i, j, options, _i, _j, _len, _len1;
      options = jsOptions(series, opts);
      options.xAxis.type = "datetime";
      options.chart = {
        type: "spline",
        renderTo: element.id
      };
      for (_i = 0, _len = series.length; _i < _len; _i++) {
        i = series[_i];
        data = series[i].data;
        for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
          j = data[_j];
          data[j][0] = data[j][0].getTime();
        }
        series[i].marker = {
          symbol: "circle"
        };
      }
      options.series = series;
      return new Highcharts.Chart(options);
    };
    renderPieChart = function(element, series, opts) {
      var options;
      options = merge(defaultOptions, opts.library || {});
      options.chart = {
        renderTo: element.id
      };
      options.series = [
        {
          type: "pie",
          name: "Value",
          data: series
        }
      ];
      return new Highcharts.Chart(options);
    };
    renderColumnChart = function(element, series, opts) {
      var categories, d, i, j, newSeries, options, rows, s, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      options = jsOptions(series, opts);
      rows = [];
      options.chart = {
        type: "column",
        renderTo: element.id
      };
      for (_i = 0, _len = series.length; _i < _len; _i++) {
        i = series[_i];
        s = series[i];
        for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
          j = data[_j];
          d = s.data[j];
          if (!rows[d[0]]) {
            rows[d[0]] = new Array(series.length);
          }
          rows[d[0]][i] = d[1];
        }
      }
      categories = [];
      for (i in rows) {
        if (rows.hasOwnProperty(i)) {
          categories.push(i);
        }
      }
      options.xAxis.categories = categories;
      newSeries = [];
      for (_k = 0, _len2 = series.length; _k < _len2; _k++) {
        i = series[_k];
        d = [];
        for (_l = 0, _len3 = categories.length; _l < _len3; _l++) {
          j = categories[_l];
          d.push(rows[categories[j]][i]);
        }
        newSeries.push({
          name: series[i].name,
          data: d
        });
      }
      options.series = newSeries;
      return new Highcharts.Chart(options);
    };
  } else if ("google" in window) {
    loaded = false;
    google.setOnLoadCallback = function() {
      return loaded = true;
    };
    google.load("visualization", "1.0", {
      "packages": ["corechart"]
    });
    waitForLoaded = function(callback) {
      google.setOnLoadCallback(callback);
      if (loaded) {
        return callback();
      }
    };
    defaultOptions = {
      fontName: "'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif",
      pointSize: 6,
      legend: {
        textStyle: {
          fontSize: 12,
          color: "#444"
        },
        alignment: "center",
        position: "right"
      },
      curveType: "function",
      hAxis: {
        textStyle: {
          color: "#666",
          fontSize: 12
        },
        gridlines: {
          color: "transparent"
        },
        baselineColor: "#ccc"
      },
      vAxis: {
        textStyle: {
          color: "#666",
          fontSize: 12
        },
        baselineColor: "#ccc",
        viewWindow: {}
      },
      tooltip: {
        textStyle: {
          color: "#666",
          fontSize: 12
        }
      }
    };
    hideLegend = function(options) {
      return options.legend.position = "none";
    };
    setMin = function(options, min) {
      return options.vAxis.viewWindow.min = min;
    };
    setMax = function(options, max) {
      return options.vAxis.viewWindow.max = max;
    };
    jsOptions = jsOptionsFunc(defaultOptions, hideLegend, setMin, setMax);
    createDataTable = function(series, columnType) {
      var d, data, i, j, key, rows, rows2, s, _i, _j, _len, _len1, _ref;
      data = new google.visualization.DataTable();
      data.addColumn(columnType, "");
      rows = [];
      for (_i = 0, _len = series.length; _i < _len; _i++) {
        i = series[_i];
        s = series[i];
        data.addColumn("number", s.name);
        _ref = s.data;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          j = _ref[_j];
          d = s.data[j];
          key = columnType === "datetime" ? d[0].getTime() : d[0];
          if (!rows[key]) {
            rows[key] = new Array(series.length);
          }
          rows[key][i] = toFloat(d[1]);
        }
      }
      rows2 = [];
      for (i in rows) {
        if (rows.hasOwnProperty(i)) {
          rows2.push([columnType === "datetime" ? new Date(toFloat(i)) : i].concat(rows[i]));
        }
      }
      if (columnType === "datetime") {
        rows2.sort(sortByTime);
      }
      data.addRows(rows2);
      return data;
    };
    renderLineChart = function(element, series, opts) {
      return waitForLoaded = function() {
        var chart, data, options;
        options = jsOptions(series, opts);
        data = createDataTable(series, "datetime");
        chart = new google.visualization.LineChart(element);
        return chart.draw(data, options);
      };
    };
    renderPieChart = function(element, series, opts) {
      return waitForLoaded = function() {
        var chart, data, options;
        options = merge(defaultOptions, opts.library || {});
        options.chartArea = {
          top: "10%",
          height: "80%"
        };
        data = new google.visualization.DataTable();
        data.addColumn("string", "");
        data.addColumn("number", "Value");
        data.addRows(series);
        chart = new google.visualization.PieChart(element);
        return chart.draw(data, options);
      };
    };
    renderColumnChart = function(element, series, opts) {
      return waitForLoaded = function() {
        var chart, data, options;
        options = jsOptions(series, opts);
        data = createDataTable(series, "string");
        chart = new google.visualization.ColumnChart(element);
        return chart.draw(data, options);
      };
    };
  } else {
    renderLineChart = renderPieChart = renderColumnChart = function() {
      throw new Error("Please install Google Charts or Highcharts");
    };
  }

  setText = function(element, text) {
    if (document.body.innerText) {
      return element.innerText = text;
    } else {
      return element.textContent = text;
    }
  };

  chartError = function(element, message) {
    setText(element, "Error Loading Chart: " + message);
    return element.style.color = "#ff0000";
  };

  getJSON = function(element, url, success) {
    return $.ajax({
      dataType: "json",
      url: url,
      success: success,
      error: function(jqXHR, textStatus, errorThrown) {
        var message;
        message = typeof errorThrown === "string" ? errorThrown : errorThrown.message;
        return chartError(element, message);
      }
    });
  };

  errorCatcher = function(element, data, opts, callback) {
    var err;
    try {
      return callback(element, data, opts);
    } catch (_error) {
      err = _error;
      chartError(element, err.message);
      throw err;
    }
  };

  fetchDataSource = function(element, dataSource, opts, callback) {
    if (typeof dataSource === "string") {
      return getJSON(element, dataSource, function(data, textStatus, jqXHR) {
        return errorCatcher(element, data, opts, callback);
      });
    } else {
      return errorCatcher(element, dataSource, opts, callback);
    }
  };

  toStr = function(n) {
    return "" + n;
  };

  toFloat = function(n) {
    return parseFloat(n);
  };

  toDate = function(n) {
    var str;
    if (typeof n !== "object") {
      if (typeof n === "number") {
        n = new Date(n * 1000);
      } else {
        str = n.replace(/\ /, "T").replace(" ", "").replace("UTC", "Z");
        n = parseISO8601(str) || new Date(n);
      }
    }
    return n;
  };

  toArr = function(n) {
    var arr, i;
    if (!isArray(n)) {
      arr = [];
      for (i in n) {
        if (n.hasOwnProperty(i)) {
          arr.push([i, n[i]]);
        }
      }
      n = arr;
    }
    return n;
  };

  sortByTime = function(a, b) {
    return a[0].getTime() - b[0].getTime();
  };

  processSeries = function(series, opts, time) {
    var data, key, obj, r, _i, _j, _len, _len1;
    if (!isArray(series) || typeof series[0] !== "object" || isArray(series[0])) {
      series = [
        {
          name: "Value",
          data: series
        }
      ];
      opts.hideLegend = true;
    } else {
      opts.hideLegend = false;
    }
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      obj = series[_i];
      data = toArr(obj.data);
      r = [];
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        obj = data[_j];
        key = obj[0];
        key = time ? toDate(key) : toStr(key);
        r.push([key, toFloat(obj[1])]);
      }
      if (time) {
        r.sort(sortByTime);
      }
      obj.data = r;
    }
    return series;
  };

  processLineData = function(element, data, opts) {
    return renderLineChart(element, processSeries(data, opts, true), opts);
  };

  processColumnData = function(element, data, opts) {
    return renderColumnChart(element, processSeries(data, opts, false), opts);
  };

  processPieData = function(element, data, opts) {
    var obj, perfectData, _i, _len;
    perfectData = toArr(data);
    for (_i = 0, _len = perfectData.length; _i < _len; _i++) {
      obj = perfectData[_i];
      obj = [toStr(obj[0]), toFloat(obj[1])];
    }
    return renderPieChart(element, perfectData, opts);
  };

  setElement = function(element, data, opts, callback) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    return fetchDataSource(element, data, opts || {}, callback);
  };

  Chartkick = {
    LineChart: function(element, dataSource, opts) {
      return setElement(element, dataSource, opts, processLineData);
    },
    ColumnChart: function(element, dataSource, opts) {
      return setElement(element, dataSource, opts, processColumnData);
    },
    PieChart: function(element, dataSource, opts) {
      return setElement(element, dataSource, opts, processPieData);
    }
  };

  window.Chartkick = Chartkick;

}).call(this);
