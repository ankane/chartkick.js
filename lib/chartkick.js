// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var Chartkick, DECIMAL_SEPARATOR, ISO8601_PATTERN, chartError, errorCatcher, extend, fetchDataSource, getJSON, isArray, isFunction, isPlainObject, merge, negativeValues, parseISO8601, processSeries, processSimple, processTime, renderChart, setElement, setText, sortByTime, toArr, toDate;

  isArray = function(variable) {
    return Object.prototype.toString.call(variable) === '[object Array]';
  };

  isFunction = function(variable) {
    return variable instanceof Function;
  };

  isPlainObject = function(variable) {
    return !isFunction(variable) && variable instanceof Object;
  };

  extend = function(target, source) {
    var item, key;
    for (key in source) {
      item = source[key];
      if (isPlainObject(item) || isArray(item)) {
        if (isPlainObject(item) && !isPlainObject(target[key])) {
          target[key] = {};
        }
        if (isArray(item) && !isArray(target[key])) {
          target[key] = [];
        }
        extend(target[key], item);
      } else if (item !== void 0) {
        target[key] = item;
      }
    }
    return target;
  };

  merge = function(obj1, obj2) {
    return extend(extend({}, obj1), obj2);
  };

  ISO8601_PATTERN = /(\d\d\d\d)(\-)?(\d\d)(\-)?(\d\d)(T)?(\d\d)(:)?(\d\d)?(:)?(\d\d)?([\.,]\d+)?($|Z|([\+\-])(\d\d)(:)?(\d\d)?)/i;

  DECIMAL_SEPARATOR = String(1.5).charAt(1);

  parseISO8601 = function(input) {
    var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year, _ref;
    type = Object.prototype.toString.call(input);
    if (type === '[object Date]') {
      return input;
    }
    if (type !== '[object String]') {
      return;
    }
    if (!(matches = input.match(ISO8601_PATTERN))) {
      return;
    }
    year = parseInt(matches[1], 10);
    month = parseInt(matches[3], 10) - 1;
    day = parseInt(matches[5], 10);
    hour = parseInt(matches[7], 10);
    minutes = matches[9] ? parseInt(matches[9], 10) : 0;
    seconds = matches[11] ? parseInt(matches[11], 10) : 0;
    milliseconds = matches[12] ? parseFloat(DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;
    result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);
    if (matches[13] && matches[14]) {
      offset = matches[15] * 60;
      if (matches[17]) {
        offset += parseInt(matches[17], 10);
      }
      offset *= (_ref = matches[14] === '-') != null ? _ref : -{
        1: 1
      };
      result -= offset * 60 * 1000;
    }
    return new Date(result);
  };

  negativeValues = function(series) {
    var item, section, _i, _j, _len, _len1, _ref;
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      section = series[_i];
      _ref = section.data;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        item = _ref[_j];
        if (item[1] < 0) {
          return true;
        }
      }
    }
    return false;
  };

  setText = function(element, text) {
    if (document.body.innerText) {
      return element.innerText = text;
    } else {
      return element.textContent = text;
    }
  };

  chartError = function(element, message) {
    setText(element, "Error Loading Chart: " + message);
    return element.style.color = '#ff0000';
  };

  getJSON = function(element, url, success) {
    var $;
    $ = window.jQuery || window.Zepto || window.$;
    return $.ajax({
      dataType: 'json',
      url: url,
      success: success,
      error: function(jqXHR, textStatus, errorThrown) {
        var message;
        message = typeof errorThrown === 'string' ? errorThrown : errorThrown.message;
        return chartError(element, message);
      }
    });
  };

  errorCatcher = function(chart, callback) {
    var err;
    try {
      return callback(chart);
    } catch (_error) {
      err = _error;
      chartError(chart.element, err.message);
      throw err;
    }
  };

  fetchDataSource = function(chart, callback) {
    if (typeof chart.dataSource === 'string') {
      return getJSON(chart.element, chart.dataSource, function(data, textStatus, jqXHR) {
        chart.data = data;
        return callback(chart);
      });
    } else {
      chart.data = chart.dataSource;
      return callback(chart);
    }
  };

  toDate = function(n) {
    var str;
    if (typeof n === 'object') {
      return n;
    }
    if (typeof n === 'number') {
      return new Date(n * 1000);
    } else {
      str = n.replace(/\ /, 'T').replace(' ', '').replace('UTC', 'Z');
      return parseISO8601(str) || new Date(n);
    }
  };

  toArr = function(n) {
    var k, v, _results;
    if (isArray(n)) {
      return n;
    }
    _results = [];
    for (k in n) {
      v = n[k];
      if (n.hasOwnProperty(k)) {
        _results.push([k, v]);
      }
    }
    return _results;
  };

  sortByTime = function(a, b) {
    return a[0].getTime() - b[0].getTime();
  };

  renderChart = function(chartType, chart) {
    var adapter, adapter_name, fn_name, _i, _len, _ref;
    fn_name = "render" + chartType;
    adapter_name = chart.options.adapter;
    _ref = Chartkick.adapters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      adapter = _ref[_i];
      if ((!adapter_name || adapter_name === adapter.name) && isFunction(adapter[fn_name])) {
        return adapter[fn_name](chart);
      }
    }
    throw new Error('No adapter found');
  };

  processSeries = function(series, opts, time) {
    var item, key, section, _i, _len;
    if (!isArray(series) || typeof series[0] !== 'object' || isArray(series[0])) {
      series = [
        {
          name: 'Value',
          data: series
        }
      ];
      opts.hideLegend = true;
    } else {
      opts.hideLegend = false;
    }
    if (opts.discrete) {
      time = false;
    }
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      section = series[_i];
      section.data = (function() {
        var _j, _len1, _ref, _results;
        _ref = toArr(section.data);
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          item = _ref[_j];
          key = time ? toDate(item[0]) : "" + item[0];
          _results.push([key, parseFloat(item[1])]);
        }
        return _results;
      })();
      if (time) {
        section.data.sort(sortByTime);
      }
    }
    return series;
  };

  processSimple = function(data) {
    var item, _i, _len, _ref;
    _ref = toArr(data);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      item = ["" + item[0], parseFloat(item[1])];
    }
    return data;
  };

  processTime = function(data) {
    var item, _i, _len;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      item[1] = toDate(item[1]);
      item[2] = toDate(item[2]);
    }
    return data;
  };

  setElement = function(chart, element, dataSource, opts, callback) {
    if (typeof element === 'string') {
      element = document.getElementById(element);
    }
    chart.element = element;
    chart.options = opts || {};
    chart.dataSource = dataSource;
    Chartkick.charts[element.id] = chart;
    return fetchDataSource(chart, callback);
  };

  Chartkick = {
    adapters: [],
    config: window.Chartkick || {},
    charts: {},
    LineChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSeries(chart.data, chart.options, true);
        return renderChart('LineChart', chart);
      });
    },
    PieChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSimple(chart.data);
        return renderChart('PieChart', chart);
      });
    },
    ColumnChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSeries(chart.data, chart.options, false);
        return renderChart('ColumnChart', chart);
      });
    },
    BarChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSeries(chart.data, chart.options, false);
        return renderChart('BarChart', chart);
      });
    },
    AreaChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSeries(chart.data, chart.options, true);
        return renderChart('AreaChart', chart);
      });
    },
    GeoChart: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processSimple(chart.data);
        return renderChart('GeoChart', chart);
      });
    },
    Timeline: function(element, dataSource, opts) {
      return setElement(this, element, dataSource, opts, function(chart) {
        chart.data = processTime(chart.data);
        return renderChart('Timeline', chart);
      });
    },
    utils: {
      merge: merge,
      sortByTime: sortByTime,
      jsOptionsFunc: function(defaultOptions, hideLegend, setMin, setMax, setStacked) {
        return function(series, opts, chartOptions) {
          var options;
          options = merge(defaultOptions, chartOptions || {});
          if (opts.hideLegend) {
            hideLegend(options);
          }
          if ('min' in opts) {
            setMin(options, opts.min);
          } else {
            if (!negativeValues(series)) {
              setMin(options, 0);
            }
          }
          if ('max' in opts) {
            setMax(options, opts.max);
          }
          if (opts.stacked) {
            setStacked(options);
          }
          if (opts.colors) {
            options.colors = opts.colors;
          }
          if (opts.library) {
            return merge(options, opts.library);
          } else {
            return options;
          }
        };
      }
    }
  };

  window.Chartkick = Chartkick;

}).call(this);
